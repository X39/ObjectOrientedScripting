using Compiler.OOS_LanguageObjects;
using Compiler.OOS_LanguageObjects.HelperClasses;
using Compiler.OOS_LanguageObjects.Ex;


COMPILER OOS

CHARACTERS
  DIGIT = "0123456789".
  CHARACTER = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".
  UNDERSCORE = '_'.
  OTHER = ANY - '/' - '*'. 
  ALL = ANY.
  STRINGCHARS = ANY - '\n' - '\r' - '"'.

TOKENS
	UINTEGER = DIGIT { DIGIT }.
	UDOUBLE = DIGIT { DIGIT } '.' DIGIT { DIGIT }.
	INTEGER = ('-' | '+') DIGIT { DIGIT }.
	DOUBLE = ('-' | '+') DIGIT { DIGIT } '.' DIGIT { DIGIT }.
	FQIDENT = ["::"] ( CHARACTER { CHARACTER | UNDERSCORE | DIGIT } ) { "::" ( CHARACTER { CHARACTER | UNDERSCORE | DIGIT } ) } [ '.' ( CHARACTER { CHARACTER | UNDERSCORE | DIGIT } ) ].
	LOCALIDENT = UNDERSCORE ( CHARACTER | UNDERSCORE) {CHARACTER | UNDERSCORE | DIGIT } [ '.' ( CHARACTER { CHARACTER | UNDERSCORE | DIGIT } ) ].
	LINETERMINATOR = ';'.
	STRING = '"' { STRINGCHARS | "\\\""} '"'.
	COMMA = ','.
	
COMMENTS FROM "/*" TO "*/" NESTED
COMMENTS FROM "//" TO '\n'
IGNORE '\t' + '\r' + '\n'
	
PRODUCTIONS

	

	SCALAR<out BaseLangObject bloOut>										(. var v = new OosValue(); bloOut = (BaseLangObject)v; .)
	=
		DOUBLE																(. v.Value = t.val; .)
		|
		INTEGER																(. v.Value = t.val; .)
	.
	
	ARRAY<out BaseLangObject bloOut>										(. var v1 = new OosValue(); bloOut = (BaseLangObject)v1;  BaseLangObject v2; .)
	=
		'['																	(. v1.append("["); .)
		VALUE<out v2>														(. v1.append((OosValue)v2); .)
		{
			COMMA															(. v1.append(","); .)
			VALUE<out v2>													(. v1.append((OosValue)v2); .)
		}
		']'																	(. v1.append("]"); .)
	.
	
    VALUE<out BaseLangObject bloOut>										(. var v = new OosValue(); bloOut = (BaseLangObject)v;  .)
	=
		SCALAR<out bloOut>
		|
		STRING																(. v.Value = t.val; .)
		|
		ARRAY<out bloOut>
		|
		"true"																(. v.Value = t.val; .)
		|
		"false"																(. v.Value = t.val; .)
	.
	
	ENCAPSULATION<out ClassEncapsulation e>									(. e = ClassEncapsulation.PUBLIC; .)
	=
		"private"															(. e = ClassEncapsulation.PRIVATE; .)
		|
		"public"															(. e = ClassEncapsulation.PUBLIC; .)
	.
	ASSIGNMENTOPERATORS<out AssignmentOperators ao>							(. ao = AssignmentOperators.Equals; .)
	=
		"+="																(. ao = AssignmentOperators.PlusEquals; .)
		|
		"-="																(. ao = AssignmentOperators.MinusEquals; .)
		|
		"*="																(. ao = AssignmentOperators.MultipliedEquals; .)
		|
		"/="																(. ao = AssignmentOperators.DividedEquals; .)
		|
		'='																	(. ao = AssignmentOperators.Equals; .)
	.
	OOS																		(. oosTreeBase = new OosContainer(); BaseLangObject blo; .)
	=
		{
			NAMESPACE<out blo>												(. oosTreeBase.addChild(blo); .)
			|
			CLASS<out blo>													(. oosTreeBase.addChild(blo); .)
			|IF(scanner.FollowedBy("function"))
			GLOBALFUNCTION<out blo>											(. oosTreeBase.addChild(blo); .)
			|
			GLOBALVARIABLE<out blo>											(. oosTreeBase.addChild(blo); .)
		}
	.
	NAMESPACE<out BaseLangObject bloOut>									(. var n = new OosNamespace(); bloOut = (BaseLangObject)n; BaseLangObject blo; .)
	=
		"namespace"
		FQIDENT																(. n.Name = t.val; .)
		'{'
		{
			NAMESPACE<out blo>												(. n.addChild(blo); .)
			|
			CLASS<out blo>													(. n.addChild(blo); .)
			|IF(scanner.FollowedBy("function"))
			GLOBALFUNCTION<out blo>											(. n.addChild(blo); .)
			|
			GLOBALVARIABLE<out blo>											(. n.addChild(blo); .)
		}
		'}'
		[LINETERMINATOR {LINETERMINATOR}]
	.
	CLASS<out BaseLangObject bloOut>										(. var c = new OosClass(); bloOut = (BaseLangObject)c; BaseLangObject blo; .)
	=
		"class"
		FQIDENT																(. c.Name = t.val; .)
		[
			':'
			FQIDENT															(. c.ParentClasses.Add(t.val); .)
			{
				COMMA
				FQIDENT														(. c.ParentClasses.Add(t.val); .)
			}
		]
		'{'
		{
			CLASS<out blo>													(. c.addChild(blo); blo.setParent(c); .)
			|
			CLASSCONSTRUCTOR<out blo>										(. c.addChild(blo); blo.setParent(c); ((BaseFunctionObject)blo).Name = c.Name; .)
			|
			( IF(scanner.FollowedBy("function"))
				GLOBALFUNCTION<out blo>										(. c.addChild(blo); blo.setParent(c); .)
				|
				GLOBALVARIABLE<out blo>										(. c.addChild(blo); blo.setParent(c); .)
			)
			|
			( IF(scanner.FollowedByWO("function"))
				CLASSFUNCTION<out blo>										(. c.addChild(blo); blo.setParent(c); .)
				|
				CLASSVARIABLE<out blo>										(. c.addChild(blo); blo.setParent(c); .)
			)
		}
		'}'
		[LINETERMINATOR {LINETERMINATOR}]
	.
	ARGLIST<out ListString l>												(. l = new ListString(); .)
	=
		'('
		[
			FQIDENT
			{
				','
				FQIDENT														(. l.Add(t.val); .)
			}
		]
		')'
	.
	CLASSCONSTRUCTOR<out BaseLangObject bloOut>								(. var cf = new OosClassFunction(); bloOut = (BaseLangObject)cf; BaseLangObject blo; ListString argL;.)
	=
		"constructor"
		ARGLIST<out argL>													(. cf.ArgList = argL.getList(); .)
		'{'
			{
				(
					CODEINSTRUCTION<out blo>								(. cf.addChild(blo); .)
					LINETERMINATOR {LINETERMINATOR}
				)
				|
				CODEINSTRUCTION_OPTIONALSC<out blo>							(. cf.addChild(blo); .)
				[LINETERMINATOR {LINETERMINATOR}]
			}
		'}'
		[LINETERMINATOR {LINETERMINATOR}]
	.
	CLASSFUNCTION<out BaseLangObject bloOut>								(. var cf = new OosClassFunction(); bloOut = (BaseLangObject)cf; BaseLangObject blo; ListString argL; ClassEncapsulation e;.)
	=
		[
			ENCAPSULATION<out e>											(. cf.Encapsulation = e; .)
		]
		"function"
		[
			"override"														(. cf.OverrideBase = true; .)
		]
		FQIDENT																(. cf.Name = t.val; .)
		ARGLIST<out argL>													(. cf.ArgList = argL.getList(); .)
		'{'
			{
				(
					CODEINSTRUCTION<out blo>								(. cf.addChild(blo); .)
					LINETERMINATOR {LINETERMINATOR}
				)
				|
				CODEINSTRUCTION_OPTIONALSC<out blo>							(. cf.addChild(blo); .)
				[LINETERMINATOR {LINETERMINATOR}]
			}
		'}'
		[LINETERMINATOR {LINETERMINATOR}]
	.
	GLOBALFUNCTION<out BaseLangObject bloOut>								(. var gf = new OosGlobalFunction(); bloOut = (BaseLangObject)gf; BaseLangObject blo; ListString argL;.)
	=
		"static"
		"function"
		FQIDENT																(. gf.Name = t.val; .)
		ARGLIST<out argL>													(. gf.ArgList = argL.getList(); .)
		'{'
			{
				(
					CODEINSTRUCTION<out blo>								(. gf.addChild(blo); .)
					LINETERMINATOR {LINETERMINATOR}
				)
				|
				CODEINSTRUCTION_OPTIONALSC<out blo>							(. gf.addChild(blo); .)
				[LINETERMINATOR {LINETERMINATOR}]
			}
		'}'
		[LINETERMINATOR {LINETERMINATOR}]
	.
	CLASSVARIABLE<out BaseLangObject bloOut>								(. var cv = new OosClassVariable(); bloOut = (BaseLangObject)cv; ClassEncapsulation e; BaseLangObject blo; .)
	=
		[
			ENCAPSULATION<out e>											(. cv.Encapsulation = e; .)
		]
		"auto"
		FQIDENT																(. cv.Name = t.val; .)
		[
			'='
			EXPRESSION<out blo>												(. cv.Value = blo; .)
		]
		LINETERMINATOR {LINETERMINATOR}
	.
	GLOBALVARIABLE<out BaseLangObject bloOut>								(. var gv = new OosGlobalVariable(); bloOut = (BaseLangObject)gv; BaseLangObject blo; .)
	=
		"static"
		"auto"
		FQIDENT																(. gv.Name = t.val; .)
		[
			'='
			EXPRESSION<out blo>												(. gv.Value = blo; .)
		]
		LINETERMINATOR {LINETERMINATOR}
	.
	EXPRESSION_OPERATOR<out ExpressionOperator eo>							(. eo = ExpressionOperator.Plus; .)
	=
		(
			'&'																(. eo = ExpressionOperator.And; .)
			[
				'&'															(. eo = ExpressionOperator.AndAnd; .)
			]
		)
		|
		(
			'|'																(. eo = ExpressionOperator.Or; .)
			[
				'|'															(. eo = ExpressionOperator.OrOr; .)
			]
		)
		|
		(
			"=="															(. eo = ExpressionOperator.Equals; .)
			[
				'='															(. eo = ExpressionOperator.ExplicitEquals; .)
			]
		)
		|
		'+'																	(. eo = ExpressionOperator.Plus; .)
		|
		'-'																	(. eo = ExpressionOperator.Minus; .)
		|
		'*'																	(. eo = ExpressionOperator.Multiplication; .)
		|
		'/'																	(. eo = ExpressionOperator.Division; .)
	.
	EXPRESSION_SINGLE<out BaseLangObject bloOut>							(. bloOut = null; .)
	=
		VALUE<out bloOut>
		|
		OBJECTCREATION<out bloOut>
		|IF(scanner.FollowedBy("("))
		FUNCTIONCALL<out bloOut>
		|
		FQIDENT																(. bloOut = new OosVariable(t.val); .)
		|
		LOCALIDENT															(. bloOut = new OosVariable(t.val); .)
	.
	EXPRESSION_HELPER<out BaseLangObject bloOut>							(. var e = new OosExpression(); bloOut = (BaseLangObject)e; BaseLangObject blo; ExpressionOperator eo; .)
	=
		[
			'!'																(. e.Negate = true; .)
		]
		EXPRESSION_SINGLE<out blo>											(. e.LInstruction = blo; .)
		{
			EXPRESSION_OPERATOR<out eo>										(. e.Op = eo; .)
			EXPRESSION<out blo>												(. e.RInstruction = blo; .)
		}
	.
	EXPRESSION<out BaseLangObject bloOut>									(. bloOut = null; .)
	=
		(
			'('
			EXPRESSION_HELPER<out bloOut>
			')'
		)
		|
		EXPRESSION_HELPER<out bloOut>
	.
	LOCALVARIABLE<out BaseLangObject bloOut>								(. var lv = new OosLocalVariable(); bloOut = (BaseLangObject)lv; BaseLangObject blo; .)
	=
		"auto"
		LOCALIDENT															(. lv.Name = t.val; .)
		[
			'='
			EXPRESSION<out blo>												(. lv.Value = blo; .)
		]
	.
	ASSIGNMENT<out BaseLangObject bloOut>									(. string v1 = ""; string v2 = ""; bloOut = null; BaseLangObject blo; .)
	=
		(
			FQIDENT															(. v1 = t.val; .)
			|
			LOCALIDENT														(. v1 = t.val; .)
		)
		[
			'['
				UINTEGER													(. v2 = t.val; .)
			']'
		]
		(
			(																(. var obj = new OosQuickAssignment(); obj.Variable = new OosVariable(v1); obj.ArrayPosition = v2; bloOut = (BaseLangObject)obj; .)
				(
					"++"													(. obj.QuickAssignmentType = QuickAssignmentTypes.PlusPlus; .)
					|
					"--"													(. obj.QuickAssignmentType = QuickAssignmentTypes.MinusMinus; .)
				)
			)
			|
			(																(. var obj = new OosVariableAssignment(); obj.Variable = new OosVariable(v1); obj.ArrayPosition = v2; bloOut = (BaseLangObject)obj; AssignmentOperators ao; .)
				ASSIGNMENTOPERATORS<out ao>									(. obj.AssignmentOperator = ao; .)
				EXPRESSION<out blo>											(. obj.Value = blo; .)
			)
		)
	.
	CALLLIST<out ListBaseLangObject l>										(. l = new ListBaseLangObject(); BaseLangObject blo; .)
	=
		'('
		[
			EXPRESSION<out blo>												(. l.Add(blo); .)
			{
				','
				EXPRESSION<out blo>											(. l.Add(blo); .)
			}
		]
		')'
	.
	FUNCTIONCALL<out BaseLangObject bloOut>									(. var fc = new OosFunctionCall(); bloOut = (BaseLangObject)fc; ListBaseLangObject cl; .)
	=
		(
			FQIDENT															(. fc.Name = t.val; .)
			|
			LOCALIDENT														(. fc.Name = t.val; .)
		)
		CALLLIST<out cl>													(. fc.ArgList = cl.getList(); .)
	.
	TYPEOF<out BaseLangObject bloOut>										(. var to = new OosTypeOf(); bloOut = (BaseLangObject)to; BaseLangObject blo; .)
	=
		("typeof" | "typeOf")
		'('
		EXPRESSION<out blo>													(. to.Argument = blo; .)
		')'
	.
	INSTANCEOF<out BaseLangObject bloOut>									(. var io = new OosInstanceOf(); bloOut = (BaseLangObject)io; BaseLangObject blo; .)
	=
		EXPRESSION<out blo>													(. io.LArgument = blo; .)
		("instanceof" | "instanceOf")
		EXPRESSION<out blo>													(. io.RArgument = blo; .)
	.
	OBJECTCREATION<out BaseLangObject bloOut>								(. var oc = new OosObjectCreation(); bloOut = (BaseLangObject)oc; ListBaseLangObject cl; .)
	=
		"new"
		FQIDENT																(. oc.Name = t.val; .)
		CALLLIST<out cl>													(. oc.ArgList = cl.getList(); .)
	.
	CODEINSTRUCTION_OPTIONALSC<out BaseLangObject bloOut>					(. bloOut = null; .)
	=
		FORLOOP<out bloOut>
		|
		WHILELOOP<out bloOut>
		|
		IFELSE<out bloOut>
		|
		TRYCATCH<out bloOut>
		|
		SWITCH<out bloOut>
	.
	CODEINSTRUCTION<out BaseLangObject bloOut>								(. bloOut = null; .)
	=
		THROWINSTRUCTION<out bloOut>
		|
		RETURNINSTRUCTION<out bloOut>
		|
		BREAKINSTRUCTION<out bloOut>
		|
		TYPEOF<out bloOut>
		|
		LOCALVARIABLE<out bloOut>
		|IF(scanner.FollowedBy("("))
		FUNCTIONCALL<out bloOut>
		|IF(scanner.FollowedBy(new string[] { "instanceof", "instanceOf" }))
		INSTANCEOF<out bloOut>
		|
		ASSIGNMENT<out bloOut>
	.
	CODEBODY<BaseLangObject bloOut>											(. BaseLangObject blo; .)
	=
		(
			(
				CODEINSTRUCTION<out blo>									(. bloOut.addChild(blo); .)
				LINETERMINATOR {LINETERMINATOR}
			)
			|
			(
				CODEINSTRUCTION_OPTIONALSC<out blo>							(. bloOut.addChild(blo); .)
				[ LINETERMINATOR { LINETERMINATOR } ]
			)
		)
		|
		(
			'{'
			{
				(
					CODEINSTRUCTION<out blo>								(. bloOut.addChild(blo); .)
					LINETERMINATOR {LINETERMINATOR}
				)
				|
				(
					CODEINSTRUCTION_OPTIONALSC<out blo>						(. bloOut.addChild(blo); .)
					[ LINETERMINATOR { LINETERMINATOR } ]
				)
			}
			'}'
		)
	.
	FORLOOP<out BaseLangObject bloOut>										(. var fl = new OosForLoop(); bloOut = (BaseLangObject)fl; BaseLangObject blo; .)
	=
		"for"
		'('
			[
				ASSIGNMENT<out blo>											(. fl.Arg1 = blo; .)
			]
			LINETERMINATOR
			[
				EXPRESSION<out blo>											(. fl.Arg1 = blo; .)
			]
			LINETERMINATOR
			[
				ASSIGNMENT<out blo>											(. fl.Arg1 = blo; .)
			]
		')'
		CODEBODY<bloOut>
	.
	WHILELOOP<out BaseLangObject bloOut>									(. var wl = new OosWhileLoop(); bloOut = (BaseLangObject)wl; BaseLangObject blo; .)
	=
		"while"
		'('
		EXPRESSION<out blo>													(. wl.Expression = blo; .)
		')'
		CODEBODY<bloOut>
	.
	CASE<out BaseLangObject bloOut>											(. var c = new OosCase(); bloOut = (BaseLangObject)c; BaseLangObject blo; .)
	=
		(
			(
				"case"
				VALUE<out blo>												(. c.Value = blo; .)
			)
			|
			"default"
		)
		':'
		CODEBODY<bloOut>
	.
	SWITCH<out BaseLangObject bloOut>										(. var s = new OosSwitch(); bloOut = (BaseLangObject)s; BaseLangObject blo; .)
	=
		"switch"
		'('
		EXPRESSION<out blo>													(. s.Expression = blo; .)
		')'
		'{'
			{
				CASE<out blo>												(. s.addChild(blo); .)
			}
		'}'
	.
	TRYCATCH<out BaseLangObject bloOut>										(. var tc = new OosTryCatch(); bloOut = (BaseLangObject)tc; .)
	=
		"try"
		CODEBODY<bloOut>
		"catch"																(. tc.markEnd(); .)
		'('
		FQIDENT																(. tc.CatchVariable = new OosVariable(t.val); .)
		')'
		CODEBODY<bloOut>
	.
	THROWINSTRUCTION<out BaseLangObject bloOut>								(. var tr = new OosThrow(); bloOut = (BaseLangObject)tr; BaseLangObject blo; .)
	=
		"throw"
		EXPRESSION<out blo>													(. tr.Expression = blo; .)
	.
	RETURNINSTRUCTION<out BaseLangObject bloOut>							(. var tr = new OosReturn(); bloOut = (BaseLangObject)tr; BaseLangObject blo; .)
	=
		"return"
		EXPRESSION<out blo>													(. tr.Expression = blo; .)
	.
	BREAKINSTRUCTION<out BaseLangObject bloOut>								(. var b = new OosBreak(); bloOut = (BaseLangObject)b; .)
	=
		"break"
	.
	IFELSE<out BaseLangObject bloOut>										(. var ie = new OosIfElse(); bloOut = (BaseLangObject)ie; BaseLangObject blo; .)
	=
		"if"
		'('
		EXPRESSION<out blo>													(. ie.Expression = blo; .)
		')'
		CODEBODY<bloOut>
		[
			"else"															(. ie.markEnd(); .)
			CODEBODY<bloOut>
		]
	.
END OOS.