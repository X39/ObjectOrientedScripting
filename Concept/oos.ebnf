using Compiler.OOS_LanguageObjects;

COMPILER OOS
	CHARACTERS
		DIGIT = "0123456789".
		CHARACTER = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".
        ACHARACTER = "!|§$%&/*+-()=?`´#~ß}][{-_".
		OTHER = ANY - '/' - '*'. 
		STRINGCHARS = ANY - '\n' - '\r' - '"'.

	TOKENS
		T_SCALAR = [ '-' ] DIGIT { DIGIT } [ '.' DIGIT { DIGIT } ].
		T_STRING = '"' { STRINGCHARS | "\\\""} '"'.
		T_IDENT = ["::"] ( CHARACTER | '_' ) { "::" | CHARACTER | '_' | DIGIT }.
		T_TERMINATOR = ';'.
		T_EXPOP = '&' | "&&" | '|' | "||" | "==" | "===" | '+' | '-' | '*' | '/' | '>' | ">=" | '<' | "<=".
		T_ASSIGNMENTCHAR = '='.
		T_ROUNDBRACKETOPEN = '('.
		T_ROUNDBRACKETCLOSE = ')'.
		T_SQUAREBRACKETOPEN = '['.
		T_SQUAREBRACKETCLOSE = ']'.
		T_CODEBRACKETOPEN = '{'.
		T_CODEBRACKETCLOSE = '}'.
		T_INSTANCEACCESS = '.'.
		T_COMMA = ','.
		T_STATICCASTOPERATOR = '§'.
		T_DYNAMICCASTOPERATOR = '$'.
		
	COMMENTS FROM "/*" TO "*/" NESTED
	COMMENTS FROM "//" TO '\n'
	COMMENTS FROM '#' TO '\n'
	IGNORE '\t' + '\r' + '\n'
		
	PRODUCTIONS
		TERMINATOR
		=
			T_TERMINATOR
			{
				T_TERMINATOR
			}
		.
		IDENT<out pBaseLangObject outObj, pBaseLangObject parent>
		=
            T_IDENT (. outObj = new Ident(parent, t.val, t.line, t.col); .)
		.
		IDENTACCESS<out pBaseLangObject outObj, pBaseLangObject parent> (. pBaseLangObject blo; pBaseLangObject ident; outObj = null; .)
		=
            [
                CAST<out outObj, parent>
            ]
            IDENT<out ident, parent> (. if(outObj == null) outObj = ident; else outObj.addChild(ident); .)
            [
                BODY_FUNCTIONCALL<out blo, ident> (. ((Ident)ident).addChild(blo); .)
                |
                BODY_ARRAYACCESS<out blo, ident> (. ((Ident)ident).addChild(blo); .)
                |
                BODY_ASSIGNMENT<out blo, ident> (. ((Ident)ident).addChild(blo); .)
            ]
            [
                T_INSTANCEACCESS
                IDENTACCESS<out blo, ident> (. ((Ident)ident).addChild(blo); .)
            ]
        .
        CAST<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Cast(parent); outObj = obj; VarType vt; pBaseLangObject ident; .)
        =
            (
                T_STATICCASTOPERATOR (. obj.isStaticCast = true; .)
                (
                    VARTYPE<out vt> (. obj.varType = new VarTypeObject(vt); .)
                    |
                    IDENT<out ident, obj> (. obj.varType = new VarTypeObject((Ident)ident); .)
                )
                T_STATICCASTOPERATOR
            )
            |
            (
                T_DYNAMICCASTOPERATOR (. obj.isStaticCast = false; .)
                (
                    VARTYPE<out vt> (. obj.varType = new VarTypeObject(vt); .)
                    |
                    IDENT<out ident, obj> (. obj.varType = new VarTypeObject((Ident)ident); .)
                )
                T_DYNAMICCASTOPERATOR
            )
        .
		ENCAPSULATION<out Encapsulation e> (. e = Encapsulation.NA; .)
		=
			"public" (. e = Encapsulation.Public; .)
			|
			"private" (. e = Encapsulation.Private; .)
			|
			"protected" (. e = Encapsulation.Protected; .)
		.
		VARTYPE<out VarType e> (. e = VarType.Void; .)
		=
            (
                "scalar" (. e = VarType.Scalar; .)
                |
                "int" (. e = VarType.Scalar; .)
                |
                "double" (. e = VarType.Scalar; .)
                |
                "float" (. e = VarType.Scalar; .)
                |
                "bool" (. e = VarType.Bool; .)
                |
                "string" (. e = VarType.String; .)
                |
                "object" (. e = VarType.Object; .)
            )
            [
                T_SQUAREBRACKETOPEN
                T_SQUAREBRACKETCLOSE(. switch(e)
                                       {
                                            case VarType.Scalar:
                                                e = VarType.ScalarArray;
                                                break;
                                            case VarType.Bool:
                                                e = VarType.BoolArray;
                                                break;
                                            case VarType.String:
                                                e = VarType.StringArray;
                                                break;
                                            default:
                                                SemErr("Cannot Arrayify VarTypes which are not string/scalar/bool");
                                                break;
                                       } .)
            ]
		.
		BOOLEAN<out bool flag> (. flag = la.val == "true"; Get(); return; .)
		=
			"true" (. flag = true; .)
			|
			"false" (. flag = false; .)
		.
		VALUE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Value(parent); outObj = obj; outObj = obj; pBaseLangObject blo; bool flag; .)
		=
			T_STRING (. obj.varType = VarType.String; obj.value = t.val; .)
			|
			T_SCALAR (. obj.varType = VarType.Scalar; obj.value = t.val; .)
			|IF(la.val == "true" || la.val == "false")
			BOOLEAN<out flag> (. obj.varType = VarType.Bool; obj.value = (flag ? "true" : "false"); .)
			|
			BOOLEAN<out flag> (. obj.varType = VarType.Bool; obj.value = (flag ? "true" : "false"); .)
		.
		EXPRESSION_HELPER<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Expression(parent, t.line, t.col); outObj = obj; pBaseLangObject blo; pBaseLangObject blo2; .)
		=
			[
				'!' (. obj.negate = true; .)
			]
			(
				OP_NEWINSTANCE<out blo, obj> (. obj.lExpression = blo; .)
				|IF( la.val == "true" || la.val == "false" )
				VALUE<out blo, obj> (. obj.lExpression = blo; .)
				|
				VALUE<out blo, obj> (. obj.lExpression = blo; .)
				|
                (
                    IDENTACCESS<out blo, obj> (. obj.lExpression = blo; .)
                    [
                        OP_INSTANCEOF<out blo, obj, blo> (. obj.lExpression = blo; .)
                    ]
                )
				|
                OP_SQFCALL<out blo, obj> (. obj.lExpression = blo; .)
			)
			{
				"++" (. obj.expOperator = t.val; .)
				|
				"--" (. obj.expOperator = t.val; .)
				|
				(
					T_EXPOP (. obj.expOperator = t.val; .)
					EXPRESSION<out blo, obj> (. obj.rExpression = blo; .)
				)
			}
		.
		EXPRESSION<out pBaseLangObject outObj, pBaseLangObject parent> (. outObj = null; .)
		=
			(
				T_ROUNDBRACKETOPEN
				EXPRESSION_HELPER<out outObj, parent>
				T_ROUNDBRACKETCLOSE
			)
            |
			EXPRESSION_HELPER<out outObj, parent>
		.
		OOS (. var obj = new Base(); baseObject = obj; pBaseLangObject blo; .)
		=
			{
				NAMESPACE<out blo, obj> (. obj.addChild(blo); .)
				|
				CLASS<out blo, obj> (. obj.addChild(blo); .)
				|
				INTERFACE<out blo, obj> (. obj.addChild(blo); .)
				|
				(
					"static"
					(
						IF( peekCompare(-1, -1, _T_TERMINATOR) )
						NEWVARIABLE<out blo, obj, Encapsulation.Static> (. obj.addChild(blo); .)
						|
						FUNCTION<out blo, obj, Encapsulation.Static> (. obj.addChild(blo); .)
					)
				)
			}
		.
		NAMESPACE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Namespace(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"namespace"
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_CODEBRACKETOPEN
			{
				NAMESPACE<out blo, obj> (. obj.addChild(blo); .)
				|
				CLASS<out blo, obj> (. obj.addChild(blo); .)
				|
				INTERFACE<out blo, obj> (. obj.addChild(blo); .)
				|
				(
					"static"
					(
						IF( peekCompare(-1, -1, _T_TERMINATOR) )
						NEWVARIABLE<out blo, obj, Encapsulation.Static> (. obj.addChild(blo); .)
						|
						FUNCTION<out blo, obj, Encapsulation.Static> (. obj.addChild(blo); .)
					)
				)
			}
			T_CODEBRACKETCLOSE
		.
		CLASS<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new oosClass(parent); outObj = obj; pBaseLangObject blo; Encapsulation e = Encapsulation.Private; bool hasConstructor = false; .)
		=
			"class"
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			[
				':'
				IDENT<out blo, obj> (. obj.addParentClass((Ident)blo); .)
				{
					','
					IDENT<out blo, obj> (. obj.addParentClass((Ident)blo); .)
				}
			]
            (. obj.markEnd(); .)
			T_CODEBRACKETOPEN
			{
                (. e = Encapsulation.Private; .)
				[
					ENCAPSULATION<out e>
					|
					"static" (. e = Encapsulation.Static; .)
				]
				(
					IF( peekCompare(-1, -1, _T_TERMINATOR) )
					(
						NEWVARIABLE<out blo, obj, e> (. obj.addChild(blo); .)
						TERMINATOR
					)
					|IF( peekCompare(_T_IDENT, _T_ROUNDBRACKETOPEN) )
					CONSTRUCTOR<out blo, obj, e> (. obj.addChild(blo); hasConstructor = true; .)
					|
					FUNCTION<out blo, obj, e> (. obj.addChild(blo); .)
				)
			}
			T_CODEBRACKETCLOSE (. if(!hasConstructor) {
                                      var constructor = new Function(obj);
                                      try
                                      {
                                        constructor.Name = obj.Name;
                                      }
                                      catch (Exception ex)
                                      {
                                        SemErr(ex.Message);
                                      }
                                      constructor.varType = new VarTypeObject(obj.Name); 
                                      constructor.markArgListEnd();
                                      obj.addChild(constructor);
                                  } .)
		.
		INTERFACE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new oosInterface(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"interface"
			IDENT<out blo, obj> (. obj.Name = (Ident)blo; .)
			T_CODEBRACKETOPEN
			{
				VFUNCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			T_CODEBRACKETCLOSE
		.
		FUNCTION<out pBaseLangObject outObj, pBaseLangObject parent, Encapsulation e> (. var obj = new Function(parent); obj.encapsulation = e; outObj = obj; pBaseLangObject blo; VarType v; .)
		=
			(
				VARTYPE<out v> (. obj.varType = new VarTypeObject(v); .)
				|
				"void" (. obj.varType = new VarTypeObject(VarType.Void); .)
				|
				IDENT<out blo, obj> (. obj.varType = new VarTypeObject((Ident)blo); .)
			)
            [
                "override" (. obj.Override = true; .)
            ]
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_ROUNDBRACKETOPEN
			[
				NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				{
					','
					NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				}
			]
			T_ROUNDBRACKETCLOSE (. obj.markArgListEnd(); .)
			T_CODEBRACKETOPEN
			{
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			T_CODEBRACKETCLOSE
			
		.
		CONSTRUCTOR<out pBaseLangObject outObj, pBaseLangObject parent, Encapsulation e> (. var obj = new Function(parent); obj.varType = new VarTypeObject(((oosClass)parent).Name, true); obj.encapsulation = e; outObj = obj; pBaseLangObject blo; .)
		=
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_ROUNDBRACKETOPEN
			[
				NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				{
					','
					NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				}
			]
			T_ROUNDBRACKETCLOSE (. obj.markArgListEnd(); .)
			T_CODEBRACKETOPEN
			{
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			T_CODEBRACKETCLOSE
			
		.
		VFUNCTION<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new VirtualFunction(parent); outObj = obj; pBaseLangObject blo; VarType v; .)
		=
			(
				VARTYPE<out v> (. obj.varType = new VarTypeObject(v); .)
				|
				"void" (. obj.varType = new VarTypeObject(VarType.Void); .)
				|
				IDENT<out blo, obj> (. obj.varType = new VarTypeObject((Ident)blo); .)
			)
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_ROUNDBRACKETOPEN
			[
				(
					VARTYPE<out v> (. obj.argTypes.Add(new VarTypeObject(v)); .)
					|
					IDENT<out blo, obj> (.  obj.argTypes.Add(new VarTypeObject((Ident)blo)); .)
				)
				{
					','
					(
						VARTYPE<out v> (. obj.argTypes.Add(new VarTypeObject(v)); .)
						|
						IDENT<out blo, obj> (. obj.argTypes.Add(new VarTypeObject((Ident)blo)); .)
					)
				}
			]
			T_ROUNDBRACKETCLOSE
			TERMINATOR
		.
		NEWVARIABLE<out pBaseLangObject outObj, pBaseLangObject parent, Encapsulation e = Encapsulation.NA> (. var obj = new Variable(parent, la.col, la.line); obj.encapsulation = e; outObj = obj; pBaseLangObject blo; VarType v; .)
		=
			(
				VARTYPE<out v> (. obj.varType = new VarTypeObject(v); .)
				|
                ( (. bool isStrict = false; .)
                    [
                        "strict" (. isStrict = true; .)
                    ]
                    IDENT<out blo, obj> (. obj.varType = new VarTypeObject((Ident)blo, isStrict); .)   
                )
			)
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
		.
		AUTOVARIABLE<out pBaseLangObject outObj, pBaseLangObject parent, Encapsulation e = Encapsulation.NA> (. var obj = new Variable(parent, la.col, la.line); obj.encapsulation = e; outObj = obj; pBaseLangObject blo; .)
		=
			"auto"(. obj.varType = new VarTypeObject(VarType.Auto); .)
			IDENT<out blo, obj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
		.
		CODEINSTRUCTION_SC<out pBaseLangObject outObj, pBaseLangObject parent> (. outObj = null; pBaseLangObject blo; .)
		=
			OP_THROW<out outObj, parent>
			|
			OP_RETURN<out outObj, parent>
			|IF( (peekString(0, "scalar", "int", "double", "float", "bool", "string", "object") && peekCompare(-1, _T_IDENT)) || peekCompare(_T_IDENT, _T_IDENT) )
			(
				NEWVARIABLE<out outObj, parent>
				[
					BODY_ASSIGNMENT<out blo, outObj> (. outObj.addChild(blo); .)
				]
			)
			|
			(
				AUTOVARIABLE<out outObj, parent>
				BODY_ASSIGNMENT<out blo, outObj> (. outObj.addChild(blo); .)
			)
			|
			EXPRESSION<out outObj, parent>
		.
		CODEINSTRUCTION_NSC<out pBaseLangObject outObj, pBaseLangObject parent> (. outObj = null; .)
		=
			OP_FOR<out outObj, parent>
			|
			OP_WHILE<out outObj, parent>
			|
			OP_IFELSE<out outObj, parent>
			|
			OP_SWITCH<out outObj, parent>
			|
			OP_TRYCATCH<out outObj, parent>
		.
		CODEINSTRUCTION<out pBaseLangObject outObj, pBaseLangObject parent> (. outObj = null; .)
		=
			(
				CODEINSTRUCTION_SC<out outObj, parent>
				TERMINATOR
			)
			|
			CODEINSTRUCTION_NSC<out outObj, parent>
		.
		BODY_ASSIGNMENT<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new VariableAssignment(parent); outObj = obj; pBaseLangObject blo; .)
		=
			T_ASSIGNMENTCHAR (. obj.operation = t.val; .)
            (
                EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
                |
                OP_NEWARRAY<out blo, obj> (. obj.addChild(blo); .)
            )
		.
		BODY_ARRAYACCESS<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new ArrayAccess(parent); outObj = obj; pBaseLangObject blo; .)
		=
			T_SQUAREBRACKETOPEN
            VALUE<out blo, obj> (. obj.addChild(blo); .)
			T_SQUAREBRACKETCLOSE
		.
		BODY_FUNCTIONCALL<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new FunctionCall(parent); outObj = obj; pBaseLangObject blo; .)
		=
			T_ROUNDBRACKETOPEN
			[
				EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
				{
					','
					EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
				}
			]
			T_ROUNDBRACKETCLOSE
		.
		OP_FOR<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new For(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"for"
			T_ROUNDBRACKETOPEN
			[
				CODEINSTRUCTION_SC<out blo, obj> (. obj.forArg1 = blo; .)
			]
			TERMINATOR
			[
				EXPRESSION<out blo, obj> (. obj.forArg2 = blo; .)
			]
			TERMINATOR
			[
				CODEINSTRUCTION_SC<out blo, obj> (. obj.forArg3 = blo; .)
			]
			T_ROUNDBRACKETCLOSE
			(
				(
					T_CODEBRACKETOPEN
					{
						CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
						|
						(
							OP_BREAK<out blo, obj> (. obj.addChild(blo); .)
							TERMINATOR
						)
					}
					T_CODEBRACKETCLOSE
				)
				|
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			)
		.
		OP_WHILE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new While(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"while"
			T_ROUNDBRACKETOPEN
			EXPRESSION<out blo, obj> (. obj.expression = blo; .)
			T_ROUNDBRACKETCLOSE
			(
				(
					T_CODEBRACKETOPEN
					{
						CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
						|
						(
							OP_BREAK<out blo, obj> (. obj.addChild(blo); .)
							TERMINATOR
						)
					}
					T_CODEBRACKETCLOSE
				)
				|
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			)
		.
		OP_NEWINSTANCE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new NewInstance(parent); outObj = obj; pBaseLangObject blo; pBaseLangObject blo2; .)
		=
			"new"
			IDENT<out blo, obj> (. obj.Name = (Ident)blo; .)
			BODY_FUNCTIONCALL<out blo2, blo> (. blo.addChild(blo2); .)
		.
		OP_NEWARRAY<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new NewArray(parent); outObj = obj; pBaseLangObject blo; .)
		=
			T_CODEBRACKETOPEN
            [
                EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
                {
                    T_COMMA
                    EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
                }
            ]
            T_CODEBRACKETCLOSE
		.
		OP_IFELSE<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new IfElse(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"if"
			T_ROUNDBRACKETOPEN
			EXPRESSION<out blo, obj> (. obj.expression = blo; .)
			T_ROUNDBRACKETCLOSE
			(
				(
					T_CODEBRACKETOPEN
					{
						CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
					}
					T_CODEBRACKETCLOSE
				)
				|
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			)
			[
				"else" (. obj.markIfEnd(); .)
				(
					(
						T_CODEBRACKETOPEN
						{
							CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
						}
						T_CODEBRACKETCLOSE
					)
					|
					CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
				)
			]
		.
		OP_TRYCATCH<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new TryCatch(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"try"
			T_CODEBRACKETOPEN
			{
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			T_CODEBRACKETCLOSE
			"catch"
			T_ROUNDBRACKETOPEN
			NEWVARIABLE<out blo, obj> (. obj.variable = blo; .)
			T_ROUNDBRACKETCLOSE (. obj.markIfEnd(); .)
			T_CODEBRACKETOPEN
			{
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			T_CODEBRACKETCLOSE
		.
		OP_BREAK<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Break(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"break"
		.
		OP_INSTANCEOF<out pBaseLangObject outObj, pBaseLangObject parent, pBaseLangObject identAccess> (. var obj = new InstanceOf(parent); outObj = obj; pBaseLangObject blo; obj.LIdent = identAccess; identAccess.Parent = obj; .)
		=
            "is"
            IDENT<out blo, obj> (. obj.RIdent = (Ident)blo; .)
		.
		OP_THROW<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Throw(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"throw"
			EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
		.
		OP_RETURN<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Return(parent, t.line, t.col); outObj = obj; pBaseLangObject blo; .)
		=
			"return"
			[
				EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
			]
		.
		OP_SWITCH<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new Switch(parent); Case caseObj; outObj = obj; pBaseLangObject blo; .)
		=
			"switch"
			T_ROUNDBRACKETOPEN
			EXPRESSION<out blo, obj> (. obj.expression = blo; .)
			T_ROUNDBRACKETCLOSE
			T_CODEBRACKETOPEN
			{
				(
					"case" (. caseObj = new Case(obj, t.line, t.col); obj.addChild(caseObj); .)
					EXPRESSION<out blo, obj> (. caseObj.expression = blo; .)
					':'
					{
						"case"
						EXPRESSION<out blo, obj> (. caseObj.addChild(blo); .)
						':'
					}
					{
						CODEINSTRUCTION<out blo, obj> (. caseObj.addChild(blo); .)
					}
					(
						OP_BREAK<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
						|
						OP_THROW<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
						|
						OP_RETURN<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
					)
				)
				|
				(
					(
						(
							"default" (. caseObj = new Case(obj, t.line, t.col); obj.addChild(caseObj); caseObj.expression = null; .)
							':'
						)
						|
						"default:" (. caseObj = new Case(obj, t.line, t.col); obj.addChild(caseObj); caseObj.expression = null; .)
					)
					{
						CODEINSTRUCTION<out blo, obj> (. caseObj.addChild(blo); .)
					}
					(
						OP_BREAK<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
						|
						OP_THROW<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
						|
						OP_RETURN<out blo, obj> (. caseObj.endOfCase = blo; .)
						TERMINATOR
					)
				)
			}
			T_CODEBRACKETCLOSE
		.
		OP_SQFCALL<out pBaseLangObject outObj, pBaseLangObject parent> (. var obj = new SqfCall(parent); outObj = obj; pBaseLangObject blo; .)
		=
			"SQF"
			[
				T_ROUNDBRACKETOPEN
				{
					EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
				}
				T_ROUNDBRACKETCLOSE
			]
			IDENT<out blo, outObj> (. try{ obj.Name = (Ident)blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			[
				T_ROUNDBRACKETOPEN (. obj.markEnd(); .)
				{
					EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
				}
				T_ROUNDBRACKETCLOSE
			]
		.
END OOS.