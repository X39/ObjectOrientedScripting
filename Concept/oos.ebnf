COMPILER OOS
	CHARACTERS
		DIGIT = "0123456789".
		CHARACTER = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".
        ACHARACTER = "!|§$%&/*+-()=?`´#~ß}][{-_".

	TOKENS
		T_SCALAR = [ '-' ] DIGIT { DIGIT } [ '.' DIGIT { DIGIT } ].
		T_STRING = '"' { CHARACTER | ACHARACTER | DIGIT | "\"" | "\'" | "\\" | "\n" | "\r" | "\t" } '"'.
		T_IDENT = ["::"] ( CHARACTER | '_' ) { "::" | CHARACTER | '_' | DIGIT } [ '.' ( CHARACTER | '_' | DIGIT ) { CHARACTER | '_' | DIGIT } ].
		T_TERMINATOR = ';'.
		T_EXPOP = '&' | "&&" | '|' | "||" | "==" | "===" | '+' | '-' | '*' | '/' | '>' | ">=" | '<' | "<=".
		T_ASSIGNMENTCHAR = '='.
		T_ROUNDBRACKETOPEN = '('.
		T_ROUNDBRACKETCLOSE = ')'.
		
	COMMENTS FROM "/*" TO "*/" NESTED
	COMMENTS FROM "//" TO '\n'
	COMMENTS FROM '#' TO '\n'
	IGNORE '\t' + '\r' + '\n'
		
	PRODUCTIONS
		TERMINATOR
		=
			T_TERMINATOR
			{
				T_TERMINATOR
			}
		.
		IDENT<out pBaseLangObject obj, pBaseLangObject parent>
		=
			T_IDENT (. obj = new Ident(parent, t.val); .)
		.
		ENCAPSULATION<out Encapsulation e>
		=
			"public" (. e = Encapsulation.Public; .)
			|
			"private" (. e = Encapsulation.Private; .)
			|
			"protected" (. e = Encapsulation.Protected; .)
		.
		VARTYPE<out VarTypes e>
		=
			"scalar" (. e = VarTypes.Scalar; .)
			|
			"bool" (. e = VarTypes.Bool; .)
			|
			"string" (. e = VarTypes.String; .)
		.
		STRING<out string o>
		=
			T_STRING (. o = t.val; .)
		.
		BOOLEAN<out bool flag>
		=
			"true" (. flag = true; .)
			|
			"false" (. flag = false; .)
		.
		VALUE
		=
			STRING
			|
			T_SCALAR
			|
			BOOLEAN
		.
		EXPRESSION_HELPER
		=
			[
				'!'
			]
			(
				VALUE
				|
				OP_NEWINSTANCE
				|
				(
					IDENT
					BODY_FUNCTIONCALL
				)
				|
				OP_SQFCALL
			)
			{
				T_EXPOP
				EXPRESSION
			}
		.
		EXPRESSION
		=
			(
				T_ROUNDBRACKETOPEN
				EXPRESSION_HELPER
				T_ROUNDBRACKETCLOSE
			)
			|
			EXPRESSION_HELPER
		.
		OOS (. Base obj = new Base(); pBaseLangObject blo; .)
		=
			{
				NAMESPACE<out blo, obj> (. base.addChild(blo); .)
				|
				CLASS<out blo> (. base.addChild(blo); .)
				|
				INTERFACE<out blo> (. base.addChild(blo); .)
			}
		.
		NAMESPACE<out pBaseLangObject obj, pBaseLangObject parent> (. obj = new Namespace(parent); pBaseLangObject blo; .)
		=
			"namespace"
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			'{'
			{
				NAMESPACE<out blo, obj> (. base.addChild(blo); .)
				|
				CLASS<out blo, obj> (. base.addChild(blo); .)
				|
				INTERFACE<out blo, obj> (. base.addChild(blo); .)
				|
				(
					"static"
					NEWVARIABLE<out blo, obj, Encapsulation.Static> (. base.addChild(blo); .)
					|
					FUNCTION<out blo, obj, Encapsulation.Static> (. base.addChild(blo); .)
				)
			}
			'}'
		.
		CLASS<out pBaseLangObject obj, pBaseLangObject parent> (. obj = new oosClass(parent); pBaseLangObject blo; .)
		=
			"class"
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			[
				':'
				IDENT<out blo> (. obj.addParentClass(blo); .)
				{
					','
					IDENT<out blo> (. obj.addParentClass(blo); .)
				}
			]
			'{'
			{ (. Encapsulation e; .)
				ENCAPSULATION<out e>
				FUNCTION<out blo, obj, e> (. base.addChild(blo); .)
				|
				NEWVARIABLE<out blo, obj, e> (. base.addChild(blo); .)
			}
			'}'
		.
		INTERFACE<out pBaseLangObject obj, pBaseLangObject parent> (. obj = new oosInterface(parent); pBaseLangObject blo; .)
		=
			"interface"
			IDENT<out blo, obj> (. obj.Name = blo; .)
			'{'
			{
				VFUNCTION<out blo, obj> (. base.addChild(blo); .)
			}
			'}'
		.
		FUNCTION<out pBaseLangObject obj, pBaseLangObject parent, Encapsulation e> (. obj = new Function(parent); pBaseLangObject blo; VarType v; .)
		=
			(
				VARTYPE<out v> (. obj.functionVarType = v; .)
				|
				"void" (. obj.functionVarType = VarType.Void; .)
			)
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_ROUNDBRACKETOPEN
			[
				NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				{
					','
					NEWVARIABLE<out blo, obj> (. obj.addChild(blo); .)
				}
			]
			T_ROUNDBRACKETCLOSE (. obj.markArgListEnd() .)
			'{'
			{
				CODEINSTRUCTION<out blo, obj> (. obj.addChild(blo); .)
			}
			'}'
			
		.
		VFUNCTION<out pBaseLangObject obj, pBaseLangObject parent, Encapsulation e> (. obj = new VirtualFunction(parent); pBaseLangObject blo; VarType v; .)
		=
			"virtual"
			(
				VARTYPE<out v> (. obj.functionVarType = v; .)
				|
				"void" (. obj.functionVarType = VarType.Void; .)
			)
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
			T_ROUNDBRACKETOPEN
			[
				VARTYPE<out v> (. obj.argTypes.Add(v); .)
				{
					','
					VARTYPE<out v> (. obj.argTypes.Add(v); .)
				}
			]
			T_ROUNDBRACKETCLOSE
			TERMINATOR
		.
		NEWVARIABLE<out pBaseLangObject obj, pBaseLangObject parent, Encapsulation e = Encapsulation.NA> (. obj = new Variable(parent); obj.encapsulation = e; pBaseLangObject blo; VarType v; .)
		=
			VARTYPE<out v> (. obj.varType = v; .)
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
		.
		AUTOVARIABLE<out pBaseLangObject obj, pBaseLangObject parent, Encapsulation e = Encapsulation.NA> (. obj = new Variable(parent); obj.encapsulation = e; pBaseLangObject blo; .)
		=
			"auto"(. obj.varType = VarType.Auto; .)
			IDENT<out blo, obj> (. try{ obj.Name = blo;} catch (Exception ex) { SemErr(ex.Message); } .)
		.
		CODEINSTRUCTION_SC<out pBaseLangObject obj, pBaseLangObject parent> (. pBaseLangObject blo; .)
		=
			OP_THROW<obj, parent>
			|
			OP_RETURN<obj, parent>
			|IF( peekCompare(_T_IDENT, _T_ROUNDBRACKETOPEN) )
			(
				IDENT<obj, parent>
				BODY_FUNCTIONCALL<blo, obj> (. obj.addChild(blo); .)
			)
			|IF( peekCompare(_T_IDENT, _T_ASSIGNMENTCHAR) )
			(
				IDENT<obj, parent>
				BODY_ASSIGNMENT<blo, obj> (. obj.addChild(blo); .)
			)
			|
			(
				NEWVARIABLE<obj, parent>
				[
					BODY_ASSIGNMENT<blo, obj> (. obj.addChild(blo); .)
				]
			)
			|
			(
				AUTOVARIABLE<obj, parent>
				BODY_ASSIGNMENT<blo, obj> (. obj.addChild(blo); .)
			)
			|
			EXPRESSION<obj, parent>
		.
		CODEINSTRUCTION_NSC<out pBaseLangObject obj, pBaseLangObject parent>
		=
			OP_FOR<obj, parent>
			|
			OP_WHILE<obj, parent>
			|
			OP_IFELSE<obj, parent>
			|
			OP_SWITCH<obj, parent>
			|
			OP_TRYCATCH<obj, parent>
		.
		CODEINSTRUCTION<out pBaseLangObject obj, pBaseLangObject parent>
		=
			(
				CODEINSTRUCTION_SC<obj, parent>
				TERMINATOR
			)
			|
			CODEINSTRUCTION_NSC<obj, parent>
		.
		BODY_ASSIGNMENT<out pBaseLangObject obj, pBaseLangObject parent> (. obj = new VariableAssignment(parent); pBaseLangObject blo; .)
		=
			T_ASSIGNMENTCHAR (. obj.operation = t.val; .)
			EXPRESSION<out blo, obj> (. obj.addChild(blo); .)
		.
		OP_FOR
		=
			"for"
			T_ROUNDBRACKETOPEN
			[
				CODEINSTRUCTION_SC
			]
			TERMINATOR
			[
				EXPRESSION
			]
			TERMINATOR
			[
				CODEINSTRUCTION_SC
			]
			T_ROUNDBRACKETCLOSE
			(
				(
					'{'
					{
						CODEINSTRUCTION
						|
						(
							OP_BREAK
							TERMINATOR
						)
					}
					'}'
				)
				|
				CODEINSTRUCTION
			)
		.
		OP_WHILE
		=
			"while"
			T_ROUNDBRACKETOPEN
			EXPRESSION
			T_ROUNDBRACKETCLOSE
			(
				(
					'{'
					{
						CODEINSTRUCTION
						|
						(
							OP_BREAK
							TERMINATOR
						)
					}
					'}'
				)
				|
				CODEINSTRUCTION
			)
		.
		OP_NEWINSTANCE
		=
			"new"
			IDENT
		.
		OP_IFELSE
		=
			"if"
			T_ROUNDBRACKETOPEN
			EXPRESSION
			T_ROUNDBRACKETCLOSE
			(
				(
					'{'
					{
						CODEINSTRUCTION
					}
					'}'
				)
				|
				CODEINSTRUCTION
			)
			[
				"else"
				(
					(
						'{'
						{
							CODEINSTRUCTION
						}
						'}'
					)
					|
					CODEINSTRUCTION
				)
			]
		.
		OP_TRYCATCH
		=
			"try"
			'{'
			{
				CODEINSTRUCTION
			}
			'}'
			"catch"
			T_ROUNDBRACKETOPEN
			NEWVARIABLE
			T_ROUNDBRACKETCLOSE
			'{'
			{
				CODEINSTRUCTION
			}
			'}'
		.
		OP_BREAK
		=
			"break"
		.
		OP_THROW
		=
			"throw"
			EXPRESSION
		.
		OP_RETURN
		=
			"return"
			[
				EXPRESSION
			]
		.
		OP_SWITCH
		=
			"switch"
			T_ROUNDBRACKETOPEN
			EXPRESSION
			T_ROUNDBRACKETCLOSE
			'{'
			{
				(
					"case"
					EXPRESSION
					':'
					{
						"case"
						EXPRESSION
						':'
					}
					{
						CODEINSTRUCTION
					}
					(
						OP_BREAK
						|
						OP_THROW
						|
						OP_RETURN
					)
				)
				|
				(
					"default"
					':'
					{
						CODEINSTRUCTION
					}
					(
						OP_BREAK
						|
						OP_THROW
						|
						OP_RETURN
					)
				)
			}
			'}'
		.
		OP_SQFCALL
		=
			"SQF"
			[
				T_ROUNDBRACKETOPEN
				{
					EXPRESSION
				}
				T_ROUNDBRACKETCLOSE
			]
			T_IDENT
			[
				T_ROUNDBRACKETOPEN
				{
					EXPRESSION
				}
				T_ROUNDBRACKETCLOSE
			]
		.
		BODY_FUNCTIONCALL
		=
			T_ROUNDBRACKETOPEN
			[
				EXPRESSION
				{
					','
					EXPRESSION
				}
			]
			T_ROUNDBRACKETCLOSE
		.
END OOS.